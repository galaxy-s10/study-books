<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /**
         * js中，函数实际上是对象，每个函数都是Fucntion的实例，所以函数本身是对象
         * 因此，函数的函数名实际是指向函数对象的一个指针，不会与某个函数绑定
         * 怎么理解“每个函数都是Fucntion的实例”？
         * 
         * */



        // function Father() { }
        // var father = new Father()

        // console.log(father.__proto__ === Father.prototype); //true
        // console.log(Function);



        // function a() {}
        // var b = a
        // a = null
        // console.log(a, b)


        // 使用function关键字定义函数
        function fn() {
            console.log('使用function关键字定义函数');
        }

        // 函数表达式，不需要函数名，通常通过变量名来调用
        var fn1 = function fn999() {
            console.log('函数表达式，不需要函数名，通常通过变量名来调用');
        }
        // console.log(fn999); //undefined
        console.log(fn1);   // fn999函数对象

        // 通过内置的 JavaScript 函数构造器（Function()）定义。
        var fn2 = new Function("console.log('通过内置的 JavaScript 函数构造器（Function()）定义。')")
        fn2.prototype.name = 'hss'
        // console.log(fn);
        // console.log(fn1);
        // console.log(fn2);
        // fn()
        // fn1()
        // fn2()
        // console.log(fn2)

        console.log(fn.prototype.constructor === fn);
        /**
         * 每个函数都是Fucntion的实例，因此，fn2.__proto__ === Function.__proto__
         * 函数本身也是对象，因此fn2.__proto__ === Function.prototype
         * */
        // console.log(fn2.prototype === fn2.__proto__)
        // fn2是通过new Function()构造的一个函数，
        // fn2可通过原型链访问Function.prototype的属性和方法
        // 因为fn2没有prototype，往上层找，fn2.__proto__有，fn2.__proto__是Function构造出来的，所以他会继承Function的prototype
        console.log('00000');
        console.log(fn2.__proto__ === Function.prototype);  //true
        console.log(fn2.__proto__ === fn2.prototype);  //false
        console.log(fn2.prototype) //{name: "hss", constructor: ƒ}
        console.log(fn2.__proto__) //ƒ () { [native code] }
        console.log(fn2.__proto__ === Function.__proto__) //true
        console.log('00000');
        console.log(fn1.__proto__ === Function.prototype);  //true
        console.log(fn1.__proto__ === fn1.prototype);  //false
        console.log(fn1.prototype) //函数的原型就是函数的原型。{constructor: ƒ}
        console.log(fn1.__proto__) //ƒ () { [native code] }
        console.log(fn1.__proto__ === Function.__proto__) //true

        // 每个 JavaScript 函数实际上都是一个 Function 对象。
        // fn2是函数，函数有prototype
        // console.log(fn2.prototype) //{name: "hss", constructor: ƒ}

        // fn2是通过Function构造器构造出来的
        // console.log(fn2.constructor) //ƒ Function() { [native code] }
        console.log(fn2.constructor === Function) //true


        // 函数的prototype===Function.prototype
        console.log(fn2.prototype.constructor) //true
        console.log(fn2.prototype.constructor === fn2) //true
        console.log(fn2.prototype.constructor.prototype === fn2.prototype) //true
        console.log(fn2.prototype === fn2.__proto__) //false
        console.log(fn2.prototype === fn2.constructor) //false

        console.log(fn2.__proto__.__proto__ === Object.prototype) //true

        console.log('-----------------------')

        // Function是函数，函数就有prototype
        console.log(Function); //ƒ Function() { [native code] }

        // Function也是Function创建的实例（构造函数），因此Function的__proto__是Function.protoype
        console.log(Function.prototype); // ƒ () { [native code] }
        console.log(Function.__proto__); // ƒ () { [native code] }

        console.log(Function.prototype === Function.__proto__); //true

        console.log(Function.prototype.prototype) //undefined
        console.log(Function.prototype.__proto__ === Object.prototype) //true
    </script>
</body>

</html>