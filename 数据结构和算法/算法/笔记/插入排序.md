# 插入排序

> 核心思想：局部有序，可以和选择排序进行比较，选择排序是每次都找所有值的最值，

## 基本原理

> 从小到大排序

> 1. 从第一个元素开始，假定他是已排序的
> 2. 取出他的下一个元素(假设他叫a)，和前面已经排序的对比，
> 3. 如果前面已经排序好的元素(假如他叫b)大于a，则排序好的元素(b)往后移
> 4. 重复3，直到找到已排序的元素小于或者等于a的位置
> 5. 将a插入到改位置
> 6. 重复上述步骤

## 复杂度

## 稳定性

> 如何判断稳定性？个人总结：
>
> 有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保证A元素依然在B元素的前面，可以说这个该算法是稳定的。

> 插入排序核心：取一个元素，拿这个元素和排序好的元素对比，如果排序好的元素比取出来的元素大/小，则把排序好的元素往后移，即只要往后移了，取出来的元素的位置就一定会改变，正因为如此，假设只有两个元素，且这两个元素相等(只有两个那也代表他们必相邻)，后一个和前一个对比，第一个不大/小于取出来对比的第二个，因此第一个不会往后移(也就是说第一个不会移到第二个的位置)，也就是说第一个还是原本的第一个，第二个也还是原本的第二个，他们的相对位置没有变(第一个还是在第二个的左边，第二个还是在第一个的右边)，所以插入排序是稳定的。



> 其实知道基本原理以及**代码实现**的话，就更好判断稳定性了。例子：[1,1]
>
> 下标1和下标0的值比较，下标值1等于下标值0，两个值相等，不走while循环，直接arr[1] =arr[1]，即原来下标的值还是1，即它是稳定性算法
>
> ```js
> function insertSort(arr) {
>     for (var i = 1; i < arr.length; i++) {
>         var j = i
>         var temp = arr[i]
>         while (arr[j - 1] > temp && j > 0) {
>             arr[j] = arr[j - 1]
>             j--
>         }
>         arr[j] = temp
>     }
>     return arr
> }
> ```

## 实现

### 从小到大

```js
// var arr = [1, 2, 3, 4, 5, 6];
// var arr = [6, 5, 4, 3, 2, 1];
var arr = [32, 14, 6, 9, 20, 58];

/**
 * 核心：取一个值（a）出来，依次和前面已排序好的值作比较，
 * 如果前面排序好的值比a大，则将该值往后移，
 * 直到找到值等于或小于a的位置，将a插入该位置，
 * 继续重复上述步骤
 */


/**
 * 原始顺序：                                   32,14,6,9,20,58
 * 选出下标为1的值和前面已经排序的1个作对比，排序后[14,32],6,9,20,58；比较了1次后换位置
 * 选出下标为2的值和前面已经排序的2个作对比，排序后[6,14,32],9,20,58；比较了2次后换位置
 * 选出下标为3的值和前面已经排序的3个作对比，排序后[6,9,14,32],20,58；比较了3次后换位置
 * 选出下标为4的值和前面已经排序的4个作对比，排序后[6,9,14,20,32],58；比较了2次后换位置
 * 选出下标为5的值和前面已经排序的5个作对比，排序后[6,9,14,20,32,58]；比较了0次后换位置
 */

// 假设当i=2，即j=2，
// 判断while循环，arr[i-1]值是14，arr[j]是6，arr[i-1]大于arr[j]，
// 即前面的元素对比的元素大，进入while循环
// 将对比的元素即arr[i-1]，往后移，即arr[i-1] =arr[j]，即arr[i-1]是arr[1]是6，
// 后移后，说明目前拿出的值还是最小值，还要继续和之前的元素对比，
// 先j--，这样下个while就可以继续和之前的元素对比
// 继续while循环，此时j=1，i还是2，arr[i-1]即arr[1]是6，
// arr[j]即arr[1]是14
// arr[i-1]为14，大于arr[i]
function insertSort(arr) {
    for (var i = 1; i < arr.length; i++) {
        // console.log(1)
        // console.log(i)
        var j = i           //保存当前取出来的元素下标
        var temp = arr[i]   //保存取出来的元素
        while (arr[j - 1] > temp && j > 0) {
            console.log(1)
            // 取出来的元素和前面的元素比较，如果前面的元素大于取出来的元素
            // 则前面的元素往后移，即把该元素(arr[j-1])移到arr[j]
            // 即arr[j]的值变成了arr[j-1]，即arr[j] = arr[j-1]
            arr[j] = arr[j - 1]

            // 下面代码是错误的!
            // arr[j-1] = arr[j]，是直接把取出来的值放到上一个位置了
            // arr[j-1] = arr[j]
            j--
        }
        // 将取出来的值放到while循环后的j位置。
        arr[j] = temp
    }
    return arr
}
```

### 从大到小

```js
function insertSort1(arr) {
    for (var i = 1; i < arr.length; i++) {
        var j = i 
        var temp = arr[i]
        while (arr[j - 1] < temp && j > 0) {
            console.log(1)
            // 取出来的元素和前面的元素比较，如果前面的元素小于取出来的元素
            // 则前面的元素往后移，即把该元素(arr[j-1])移到arr[j]
            // 即arr[j]的值变成了arr[j-1]，即arr[j] = arr[j-1]
            arr[j] = arr[j - 1]

            j--
        }
        // 将取出来的值放到while循环后的j位置。
        arr[j] = temp
    }
    return arr
}

```

