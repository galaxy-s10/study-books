# TCP协议

# TCP报文格式

![](.\image\tcp报文格式.png) 

> **端口号**：用来标识同一台计算机的不同的应用进程。

1. **TCP源端口**（Source Port）：源计算机上的应用程序的端口号，占 16 位（即2个字节，如：d5 df，即54751端口）。

2. **TCP目的端口**（Destination Port）：目标计算机的应用程序端口号，占 16 位（即2个字节，如：22 b8，即8888端口）。

3. **seq序号**（Sequence Number)：32位的序列号由接收端计算机使用，重新分段的报文成最初形式。当SYN出现，序列码实际上是初始序列码（Initial Sequence Number，ISN），而第一个数据字节是ISN+1。这个序列号（序列码）可用来补偿传输中的不一致。

4. **ack确认号**（Acknowledgment Number）：占 32 位。它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。

5. **保留字段**（Reserved）：占 6 位。为 TCP 将来的发展预留空间，目前必须全部为 0。

9. **ACK**：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。

11. **RST**：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。

12. **SYN**：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。

13. **FIN**：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。

14. 窗口大小字段，窗口大小（Window Size）：占 16 位。它表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。


# TCP三次握手

所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。
三次握手的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息.在socket编程中，客户端执行connect()时。将触发三次握手

第一次握手：客户端发送一个TCP的SYN标志位置1的包，指明客户打算连接的服务器的端口，以及选择一个初始序号（Initial Sequence Number，简称ISN）假设是X，将这个ISN保存在报文段的seq序号(Sequence Number)字段里。此时客户端进入SYN-SENT(同步发送)状态。

第二次握手：服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1，同时将确认序号ack(Acknowledgement Number)设置为客户的ISN加1以.即X+1。同时自己选择一个初始序号，假设为Y，将这个初始序号保存在报文段的seq序号字段里。此时服务端进入(SYN-RCVD同步收到)状态

第三次握手：客户端发送确认包(ACK)表示收到回复，SYN标志位为0，ACK标志位为1.并且把服务器发来ack确认号作为自己的seq序号，服务器的seq序号加1，作为自己的确认后ack，发送给对方。

# TCP四次挥手

# TCP短连接

 短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接（管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段）；过程如下：

   连接→数据传输→关闭连接；

# TCP长连接

长连接：在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（不发生RST包和四次挥手）即：Keepalive（存活定时器）功能。过程如下：

连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接（一个TCP连接通道多个读写通信）；

默认的Keepalive超时需要7,200,000 milliseconds，即2小时，探测次数为5次。

# TCP可靠传输原理

## 停止等待协议

### 无差错情况

> A发送分组M1，发完就暂停发送，等待B的确认。B收到M1就向A发送确认。A在受到了对M1的确认后，就再发送下一个分组M2。同样，在收到B对M2的确认后，再发送M3

<img src=".\image\无差错.png" alt="无差错" style="zoom:50%;" />

#### 超时重传

> 要实现超时重传，就要在每发送完一个分组时设置一个**超时计时器**。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器

- A在发送完一个分组后，**必须暂时保留已发送的分组的副本**（在发生超时重传时使用），只有在收到相应的确认后才能清除暂时保留的分组副本
- 分组和确认分组都必须进行编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认
- 超时计时器设置的重传时间**应当比数据在分组传输的平均往返时间更长一些**

<img src=".\image\超时重传.png" alt="超时重传" style="zoom: 50%;" />

#### 确认丢失

> B所发送的对M1的确认丢失了。A在设定的超时重传时间内没有收到确认，或者是B发送的确认丢失了。因此A在超时计时器到期后就要重传M1。假定B又收到了重传的分组M1。这时应采取两个行动

- 丢弃这个重复的分组M1，不向上层交付
- **向A发送确认**。不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到对M1的确认

<img src=".\image\确认丢失.png" alt="确认丢失" style="zoom:50%;" />

#### 确认迟到

> 传输过程中没有出现差错，但B对分组M1的确认迟到了。A会收到重复的确认。对重复的确认收下后就丢弃。B仍然会收到重复M1，并且同样要丢弃重复的M1，并重传确认分组

使用上述的确认和重传机制，可以**在不可靠的传输网络上实现可靠的通信**，上述这种可靠传输协议称为**自动重传请求ARQ**

<img src=".\image\确认迟到.png" alt="确认迟到" style="zoom:50%;" />

像上述这种可靠传输协议常称为***自动重传请求ARQ (Automatic Repeat reQuest)，ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组 。***换句话说就是：**我发了请求，你没有给我回应，我就要重发**

#### 信道利用率

> 停止等待协议的优点是简单，但缺点是信道利用率太低

A每次发B一条消息，等A发送消息后，就开始等待B的响应，知道等到A收到B确认了，或者等到超时了才会继续重新发消息，这样中途就会浪费很多时间

#### 流水线传输

> 发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。由于信道上一直有数据不断地传送，这种传输方式可获得很高的信道利用率

![流水线传输](.\image\流水线传输.png)

## 连续ARQ协议

![连续arq](.\image\连续arq.png)

连续ARQ（Automatic Repeat reQuest）协议指发送方维持着一个一定大小的发送窗口，位于发送窗口内的所有分组都可连续发送出去，而中途不需要等待对方的确认。这样信道的利用率就提高了。而发送方每收到一个确认就把发送窗口向前滑动一个分组的位置。

接收方一般都是采用积累确认的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已正确收到了。

积累确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。

例如，如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只是对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做Go-back-N（回退N），表示需要再退回来重传已发送过的N个分组。可见当通信线路质量不好时，连续ARQ协议会带来负面的影响。

## 滑动窗口协议

# TCP可靠传输实现

## 滑动窗口

1，首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。

<img src=".\image\1.jpg" alt="1"  /> 

2，接收端没有收到A，虽然收到了C和D，但是如果C或者D回复ACK包，则会代表C以前或者D以前的包已经收到了，所以这时接收端即是接收了2个包，但是不能回复任何ACK包。然后发送端超时重传A,B,C,D四个包，这次全都到达了。

![2](.\image\2.jpg) 

3，接收端先获得A，发ACK包A，但是中途丢失；获得B后，此时ABCD已经都接收到了，根据累计确认的原则，发D的ACK包，然后窗口滑动。再次获得C,D后，连续回复2个D的ACK包，其中C对应的ACK包丢失。

![2](.\image\3.jpg) 

4，发送端连收2个D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。现在整个序列的状态：ABCD是已发送已确认，EFGH是已发送未确认，I~S是不能发送。

![2](.\image\4.jpg) 

5，接收端先收到E，发ACK包；收到F后发F的ACK包；未收到G，还是发F的ACK包；收到H，还是发F的ACK包。不幸的是，三个ACK包全都丢失。

![2](.\image\5.jpg) 

6，发送端收到E的ACK包，窗口向右滑动一位；然后再发送F,G,H,I，其中F丢失。

![2](.\image\6.jpg) 

7，接收端获得I，因为没有G，只好回复F的ACK包。相继收到G,H包。

![2](.\image\7.jpg) 

8，接收端根据累计确认，连发两个I包，其中H对应的丢失。窗口向右滑动。

![2](.\image\8.jpg) 

9，发送端接收I的ACK包后，向右滑动四位。发送J,K,L,M四个包，后面不再分析。

![2](.\image\9.jpg) 

# 参考

https://juejin.cn/post/6844903685563105293

https://juejin.cn/post/6844904070889603085

https://juejin.cn/post/6844903826747555847

三次握手：https://juejin.cn/post/6844903510119546887